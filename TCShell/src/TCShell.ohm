TCShell {

    Program = Stmt*

    Interactive = StmtNewline

	  StmtNewline = CompoundStmt #newline	--compound
    						| SimpleStmts	--simple
                | newline
                | end

    Stmt = SimpleStmts #newline --simple
    			| CompoundStmt  --compound

    SimpleStmts = NonemptyListWithOptionalEndSep<SimpleStmt, ";">

    SimpleStmt = UnionDeclaration
                | VarDeclaration
    					  | return (Exp)?		--return
                | Exp

    CompoundStmt = Block    --block
    		  				| if Exp Stmt (else Stmt)?	--if
                  | match Exp "{" CaseStmt+ "}"    --match
          				| while Exp Stmt	--while

     CaseStmt = (Parameter | Exp | wildcard) "=>" Stmt

     Exp = AssignExp
     AssignExp = UnaryExp "=" AssignExp		--assign
     					| LorExp
     LorExp = LorExp "||" LarExp		--lor
     				| LarExp
     LarExp = LarExp "&&" EqExp		--lar
     				| EqExp
     EqExp = EqExp ("==" | "!=") RelExp		--eq
     			| RelExp
     RelExp = RelExp ( "<=" | "<" | ">=" | ">") AddExp		--rel
     				| AddExp
     AddExp = AddExp ("+" | "-") MultExp		--add
     				| MultExp
     MultExp = MultExp ( "*" | "/" | "%" ) UnaryExp		--mult
     				| UnaryExp
	   UnaryExp = ("+" | "-" | "!") UnaryExp	--unary
              | "(" Type ")" UnaryExp     --typecast
    				  | LeftExp
     LeftExp = LeftExp "(" ListOf<Exp, ","> ")"		--call
     				| LeftExp "[" Exp "]"		--array
            | PrimaryExp

    PrimaryExp = stringLiteral
    					| identifier
              | numberLiteral
              | booleanLiteral
              | noneLiteral
              | Type "(" (noneLiteral | NonemptyListOf<Parameter, ",">) ")" Stmt  --function
              | "(" Exp ")"		--group
              | "{" ListOf<Exp, ","> "}"		--array

    Block = "{" Stmt* "}"

    VarDeclaration = Parameter "=" Exp
    UnionDeclaration = UnionType "=" NonemptyListOf<Type, "|">

    Parameter = Type identifier

    TypeSpecifier = "[]"   --array
                  |"(" ListOf<Type, ","> ")"    --function

    SpatialType = landPath
                | airPath
                | MaybeVirtualSpatialType

    MaybeVirtualSpatialType = (physical | virtual)? (spatialTypeKeyword | path | MaybeImmutableSpatialType)

    MaybeImmutableSpatialType = (mutable | immutable)? (spaceKeyword | openSpace | enclosedSpace | entity | staticEntity | MaybeMobileSpatialType)

    MaybeMobileSpatialType = (stationary | mobile)? (dynamicEntity | animateEntity | smartEntity)

    Type = (baseTypeKeyword | SpatialType | UnionType) TypeSpecifier*

    baseTypeKeyword = "number" ~identPart
    						    | "string" ~identPart
                    | "bool" ~identPart
                    | "void" ~identPart

    UnionType = union identifier

    keyword = baseTypeKeyword
    				| booleanLiteral
            | noneLiteral
            | union
            | while
            | if
            | else
            | return
            | match
            | virtual
            | physical
            | mutable
            | immutable
            | stationary
            | mobile
            | spatialTypeKeyword
            | spaceKeyword
            | openSpace
            | enclosedSpace
            | entity
            | staticEntity
            | dynamicEntity
            | animateEntity
            | smartEntity
            | path
            | landPath
            | airPath
            | wildcard

    union = "union" ~identPart
    while = "while" ~identPart
    if = "if" ~identPart
    else = "else" ~identPart
    return = "return" ~identPart
    match = "match" ~identPart
    virtual = "virtual" ~identPart
    physical = "physical" ~identPart
    mutable = "mutable" ~identPart
    immutable = "immutable" ~identPart
    mobile = "mobile" ~identPart
    stationary = "stationary" ~identPart
    spatialTypeKeyword = "SpatialType" ~identPart
    spaceKeyword = "Space" ~identPart
    openSpace = "OpenSpace" ~identPart
    enclosedSpace = "EnclosedSpace" ~identPart
    entity = "Entity" ~identPart
    staticEntity = "StaticEntity" ~identPart
    dynamicEntity = "DynamicEntity" ~identPart
    animateEntity = "AnimateEntity" ~identPart
    smartEntity = "SmartEntity" ~identPart
    path = "Path" ~identPart
    landPath = "LandPath" ~identPart
    airPath = "AirPath" ~identPart
    wildcard = "_" ~identPart


    identStart      = letter | "_"
    identPart       = identStart | decimalDigit
    decimalDigit    = "0".."9"

  	identName       = identStart identPart*
    identifier      = ~keyword identName

    noneLiteral = "none" ~identPart

	  booleanLiteral = "true" ~identPart
    						| "false" ~identPart

    numberLiteral = digit+ ("." digit+ (("e" | "E") ("+" | "-") digit+)?)?

    stringLiteral = ("\"" char* "\"")   --doublequotes
    					    | ("'" char* "'")   --singlequotes
    char = ~"\"" ~"\n" any

    whitespace = "\t"       --tabchar
                | "\x0B"    --verticaltab
                | "\x0C"    --formfeed
                | " "       --space
                | "\u00A0"  --nobreakspace
                | "\uFEFF"  --byteordermark
                | unicodeSpaceSeparator   --spaceseperator

    lineTerminator = "\n" | "\r" | "\u2028" | "\u2029"
    unicodeSpaceSeparator = "\u2000".."\u200B" | "\u3000"
    space := whitespace | lineTerminator
    newline = space* end  	--last
  				  | whitespace* lineTerminator --whitespace
    NonemptyListWithOptionalEndSep<elem, sep> = NonemptyListOf<elem, sep> sep?
}
